Cole estes conteúdos nos arquivos correspondentes dentro de `docs/`:

**docs/manifest.webmanifest**

```json
{
  "name": "Crypto Sinais",
  "short_name": "Sinais",
  "start_url": "./?source=pwa",
  "scope": "./",
  "display": "standalone",
  "theme_color": "#0b1220",
  "background_color": "#0b1220",
  "icons": [
    { "src": "./icons/icon-192.png", "sizes": "192x192", "type": "image/png" },
    { "src": "./icons/icon-512.png", "sizes": "512x512", "type": "image/png" }
  ]
}
```

**docs/offline.html**

```html
<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Você está offline</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#0b1220;color:#e2e8f0;margin:0;display:grid;place-items:center;min-height:100vh}
    .card{max-width:560px;padding:24px;border-radius:16px;background:#101828;box-shadow:0 4px 20px rgba(0,0,0,.4)}
    h1{margin:0 0 12px;font-size:22px}
    p{opacity:.9}
    .hint{font-size:14px;opacity:.7;margin-top:8px}
  </style>
</head>
<body>
  <div class="card">
    <h1>Sem conexão</h1>
    <p>Alguns dados podem aparecer desatualizados. Assim que a internet voltar, atualizamos automaticamente.</p>
    <div class="hint">Dica: páginas já abertas e gráficos recentes costumam ficar em cache.</div>
  </div>
</body>
</html>
```

**docs/service-worker.js**

```js
const APP_CACHE = 'app-shell-v1';
const RUNTIME_CACHE = 'runtime-v1';
const OFFLINE_URL = './offline.html';

const APP_SHELL = [
  './',
  './index.html',
  './manifest.webmanifest',
  './offline.html',
  './icons/icon-192.png',
  './icons/icon-512.png'
];

self.addEventListener('install', event => {
  event.waitUntil(caches.open(APP_CACHE).then(cache => cache.addAll(APP_SHELL)));
  self.skipWaiting();
});

self.addEventListener('activate', event => {
  event.waitUntil(
    caches.keys().then(keys => Promise.all(keys.map(k => (k !== APP_CACHE && k !== RUNTIME_CACHE) ? caches.delete(k) : null)))
  );
  self.clients.claim();
});

self.addEventListener('fetch', event => {
  const { request } = event;

  if (request.mode === 'navigate') {
    event.respondWith((async () => {
      try {
        const fresh = await fetch(request);
        const runtime = await caches.open(RUNTIME_CACHE);
        runtime.put(request, fresh.clone());
        return fresh;
      } catch {
        const cached = await caches.match(request);
        return cached || caches.match(OFFLINE_URL);
      }
    })());
    return;
  }

  if (['style','script','image','font'].includes(request.destination)) {
    event.respondWith((async () => {
      const cached = await caches.match(request);
      const fetchPromise = fetch(request).then(async res => {
        const runtime = await caches.open(RUNTIME_CACHE);
        runtime.put(request, res.clone());
        return res;
      }).catch(() => null);
      return cached || fetchPromise || caches.match(OFFLINE_URL);
    })());
  }
});
```

> Observação: como o GitHub Pages publica o conteúdo de `docs/` como raiz do site (`/PerfeitoAbaixoVai/`), manter os caminhos **relativos** (`./...`) garante que o service worker e o manifesto funcionem corretamente.
